<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>KubernetesServiceDiscovery | William&#39;s Blog</title>
<meta name="keywords" content="kubernetes">
<meta name="description" content="Kubernetes Service和服务发现">
<meta name="author" content="deemoprobe">
<link rel="canonical" href="https://deemoprobe.github.io/posts/tech/kubernetes/kubernetesservicediscovery/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.ddb3ce53f79f05de71d690031b572b6066753a2375de82c18ef290d92427fea4.css" integrity="sha256-3bPOU/efBd5x1pADG1crYGZ1OiN13oLBjvKQ2SQn/qQ=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
        onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://deemoprobe.github.io/img/bear.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://deemoprobe.github.io/img/bear.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://deemoprobe.github.io/img/bear.gif">
<link rel="apple-touch-icon" href="https://deemoprobe.github.io/img/bear.gif">
<link rel="mask-icon" href="https://deemoprobe.github.io/img/bear.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script defer src="https://unpkg.com/mermaid@8.8.1/dist/mermaid.min.js"></script>


<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script>


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = ""; 
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<meta property="og:title" content="KubernetesServiceDiscovery" />
<meta property="og:description" content="Kubernetes Service和服务发现" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://deemoprobe.github.io/posts/tech/kubernetes/kubernetesservicediscovery/" />
<meta property="og:image" content="https://deemoprobe.github.io/img/kubernetes.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-30T02:26:47+08:00" />
<meta property="article:modified_time" content="2023-04-30T02:26:47+08:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://deemoprobe.github.io/img/kubernetes.png" />
<meta name="twitter:title" content="KubernetesServiceDiscovery"/>
<meta name="twitter:description" content="Kubernetes Service和服务发现"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [

        {
          "@type": "ListItem",
          "position":  1 ,
          "name": "📚文章",
          "item": "https://deemoprobe.github.io/posts/"
        },

        {
          "@type": "ListItem",
          "position":  2 ,
          "name": "👨🏻‍💻 技术",
          "item": "https://deemoprobe.github.io/posts/tech/"
        },

        {
          "@type": "ListItem",
          "position":  3 ,
          "name": "Kubernetes",
          "item": "https://deemoprobe.github.io/posts/tech/kubernetes/"
        }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "KubernetesServiceDiscovery",
      "item": "https://deemoprobe.github.io/posts/tech/kubernetes/kubernetesservicediscovery/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "KubernetesServiceDiscovery",
  "name": "KubernetesServiceDiscovery",
  "description": "Kubernetes Service和服务发现",
  "keywords": [
    "kubernetes"
  ],
  "articleBody": "Service是一种Pod的服务暴露机制，其他Pod可以通过这个Service访问到这个Service代理的一个或一组Pod。\n带有selector的Service在创建后会同时创建一个同名的Endpoints实例，Endpoints实例记录了selector匹配的Pod的IP地址和端口。当Pod被重建后，Endpoints会被更新，而我们使用Service名称连接后端Pod，IP变动不会对服务造成影响。\n# 集群初始化后的Service和Endpoint [root@k8s-master01 yamls]# kubectl get svc | grep kubernetes kubernetes ClusterIP 10.96.0.1 443/TCP 8d [root@k8s-master01 yamls]# kubectl get ep | grep kubernetes kubernetes 192.168.43.201:6443,192.168.43.202:6443,192.168.43.203:6443 8d 定义 假设存在一个或一组打有\"app=myapp\"标签的pod，Pod对外暴露的端口是8001，那么可以创建Service去代理这些Pod\n# 单个端口代理示例 apiVersion: v1 kind: Service metadata: name: my-service spec: selector: app: myapp # 选择带有该标签的Pod ports: - protocol: TCP # UDP TCP SCTP default: TCP port: 8080 # Service自己的端口 targetPort: 8001 # 后端应用Pod暴露的端口 # name: http # Service端口的名称 # 多个端口代理示例 apiVersion: v1 kind: Service metadata: name: my-service spec: selector: app: myapp ports: - name: http protocol: TCP port: 80 targetPort: 8001 - name: https protocol: TCP port: 443 targetPort: 8002 # 无selector的Service apiVersion: v1 kind: Service metadata: name: my-service spec: ports: - protocol: TCP port: 80 targetPort: 8001 # 由于没有selector，该Service创建后不会自动创建Endpoints实例，需要手动创建 apiVersion: v1 kind: Endpoints metadata: name: my-service subnets: - addresses: - ip: 1.2.3.4 ports: - port: 8001 # ExternalName Service，没有selector没有Endpoints，仅使用别名解析Service apiVersion: v1 kind: Service metadata: name: my-service namespace: dev spec: type: ExternalName externalName: my.nginx.example.com 说明：Service 能够将一个接收 port 映射到任意的 targetPort。 默认情况下，targetPort 将被设置为与 port 字段相同的值。\nHeadless Service 有时不需要或不想要负载均衡，以及单独的 Service IP。可以通过指定spec下面的clusterIP: None来创建 Headless Service。\n无头服务并不会分配 Cluster IP，kube-proxy 不会处理它们，而且平台也不会为它们进行负载均衡和路由。DNS如何实现自动配置，依赖于 Service 是否定义了selector。\n对于定义了selector的无头服务，Endpoint 控制器在 API 中创建了 Endpoints 记录，并且修改 DNS 配置返回 A 记录（IP 地址），通过这个地址直接到达 Service 的后端 Pod 上。\n对于没有定义selector的无头服务，Endpoint 控制器不会创建 Endpoints 记录。DNS系统会查找和配置：\n对于 ExternalName 类型的服务，查找其 CNAME 记录 对所有其他类型的服务，查找与 Service 名称相同的任何 Endpoints 的记录 Service发布类型 Kubernetes 允许指定你所需要的 Service 类型，默认是 ClusterIP，可以自定义spec字段下的type字段。type的取值以及行为如下：\nClusterIP：通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 NodePort：通过每个节点上的 IP 和静态端口（NodePort）暴露服务。NodePort服务会路由到自动创建的ClusterIP服务。通过请求\u003c节点 IP\u003e:\u003c节点端口\u003e，NodePort端口范围默认是30000-32767。可以从集群的外部访问。 LoadBalancer：使用云提供商的负载均衡器向外部暴露服务。外部负载均衡器可以将流量路由到自动创建的NodePort服务和ClusterIP服务上。 ExternalName：通过返回CNAME（别名）和对应值，可以将服务映射到 externalName 字段的内容（例如，foo.bar.example.com）。无需创建任何类型代理。 说明：kube-dns 1.7 及以上版本或者 CoreDNS 0.0.8 及以上版本才能使用 ExternalName 类型。\n# ClusterIP类型，type可以不指定 apiVersion: v1 kind: Service metadata: name: my-service spec: selector: app: myapp ports: # 默认情况下，为了方便起见，`targetPort` 被设置为与 `port` 字段相同的值。 - port: 80 targetPort: 80 # NodePort类型 apiVersion: v1 kind: Service metadata: name: my-service spec: type: NodePort selector: app: myapp ports: # 默认情况下，为了方便起见，`targetPort` 被设置为与 `port` 字段相同的值。 - port: 80 targetPort: 80 # 可选字段，不指定的话会自动设置为30000-32767中的一个 nodePort: 30007 # LoadBalancer类型，status.loadBalancer字段指定云厂商提供的负载均衡地址 apiVersion: v1 kind: Service metadata: name: my-service spec: selector: app: MyApp ports: - protocol: TCP port: 80 targetPort: 8001 clusterIP: 10.96.0.239 type: LoadBalancer status: loadBalancer: ingress: - ip: 192.0.2.127 # ExternalName类型 # 访问nginx-externalname.test.svc.cluster.local被重定向到www.baidu.com apiVersion: v1 kind: Service metadata: labels: app: nginx-externalname name: nginx-externalname namespace: test spec: type: ExternalName externalName: www.baidu.com 外部IP 如果外部IP路由到集群中一个或多个Node上，Kubernetes Service 会被暴露给这些externalIP。通过外部 IP（作为目的 IP 地址）进入到集群，流量将会被路由到 Service 的 Endpoint 上。根据 Service 的规定，externalIPs 可以同任意的 ServiceType 来一起指定。 在下面的例子中，my-service 可以通过 “80.11.12.10:80”(externalIP:port)被客户端访问。\napiVersion: v1 kind: Service metadata: name: my-service spec: selector: app: myapp ports: - name: http protocol: TCP port: 80 targetPort: 8001 externalIPs: - 80.11.12.10 Service代理模式 在 Kubernetes 集群中，kube-proxy负责为Service实现了一种VIP形式的代理，而不是ExternalName的形式。这种VIP形式的代理主要有下面两种实现方式，现在kubernetes推荐使用ipvs\niptables代理模式 在iptables模式中，kube-proxy 监视 Kubernetes的Service和Endpoints的状态变化（创建或删除），对每个 Service它都会创建iptables规则，从而捕获到达该 Service 的ClusterIP和端口的请求，进而将请求重定向到 Service 后端中的某个 Pod 上面。 对于每个 Endpoints 对象，它也会创建iptables规则，这个规则会选择一个后端pod。\n默认的策略是，kube-proxy 在 iptables 模式下随机选择一个后端。如果要确保每次都将来自特定客户端的连接传递到同一Pod（即会话保持），则可以通过设置亲和力调度策略service.spec.sessionAffinity: ClientIP（默认值是 None），来基于客户端的 IP 地址选择会话关联。还可以通过设置service.spec.sessionAffinityConfig.clientIP.timeoutSeconds来配置最大会话停留时间。（默认值为 10800 秒，即 3 小时）\nIPVS代理模式 在ipvs模式中，kube-proxy 监视 Kubernetes的Service和Endpoints的状态变化（创建或删除），调用netlink接口创建 IPVS 规则，并定期将规则与Kubernetes的Service和Endpoints同步。确保IPVS状态与所需状态匹配。访问服务时，IPVS根据规则将流量定向到后端Pod之一\n类似iptables，IPVS基于netfilter钩子函数，但是使用哈希表作为基础数据结构，在内核空间中工作，内核级的转发，所以速度很快。\nIPVS 提供以下选项来实现负载均衡：\nrr：轮询（Round-Robin） lc：最少链接（Least Connection），即打开链接数量最少者优先 dh：目标地址哈希（Destination Hashing） sh：源地址哈希（Source Hashing） sed：最短预期延迟（Shortest Expected Delay） nq：从不排队（Never Queue） 说明：要在 IPVS 模式下运行 kube-proxy，必须在启动 kube-proxy 之前使 IPVS 在节点上可用（启用IPVS可以参考高可用集群安装文档 当kube-proxy 以 IPVS 代理模式启动时，它将验证 IPVS 内核模块是否可用。 如果未检测到 IPVS 内核模块，则 kube-proxy 将退回到以 iptables 代理模式运行。\n选择合适的模式 iptables由于线性查找匹配、全量更新等特点，当规则很多时，性能会比ipvs差，所以一般推荐选择ipvs\niptables工具基于Linux内核的Netfilter模块，默认定义了多张表。每张表里包含若干内置链（chain），也可能包含用户自定义的链。每条链是一套规则（rule）列表，用于匹配一组数据包。每条规则都指定如何处理匹配的数据包。\ntable：包含一组chain的表\nchain：包含一组rule的链\nrule：匹配数据包的规则，例如：协议，端口号\ntarget：规则中的具体行为，例如：ACCEPT，DROP，INPUT，FORWARD，OUTPUT\n表\nfilter：默认表，通用数据包过滤表 mangle：为特定的数据包设计 nat：针对创建新连接的数据包 raw：主要用于结合 NOTRACK target 配置连接跟踪的豁免 security：用于MAC（Mandatory Access Control，强制访问控制）规则 规则链\nINPUT：以本机为目标的入口数据包规则链 OUTPUT：本机产生，向外转发的数据包规则链 FORWARD：路由经过本机的数据包规则链 PREROUTING：数据包进入路由之前的规则链 POSTROUTING：数据包发送到目标前（出路由）的规则链 IPtables处理链接的算法复杂度为O(n)，IPVS为O(1)，Service规模在1000内二者差距并不是很大。在Service规模超过1000后，IPtables规则链达到2000以上，性能开始下降，响应时间成倍数增加，IPVS则几乎不受Service规模的影响。Calico虽然也采用IPtables技术，但对规则链进行了优化，算法复杂度也达到了了O(1)的水平。除了大规模服务性能的差距，IPVS还具备复杂均衡算法全（轮询、最小连接数、哈希值、最小延迟等）、支持健康检查等优点。\n流量转发策略 外部流量 可以通过设置spec.externalTrafficPolicy字段来控制来自于外部的流量是如何路由的。可选值有Cluster和Local。字段设为Cluster会将外部流量路由到所有就绪的Endpoint，设为Local只会路由到当前节点上就绪的Endpoint。如果流量策略设置为Local，而当前节点上没有就绪的Endpoint，kube-proxy不会转发请求相关服务的任何流量。\n内部流量 可以通过设置spec.internalTrafficPolicy字段来控制内部来源的流量是如何转发的。可设置的值有Cluster和Local。将字段设置为Cluster会将内部流量路由到所有就绪Endpoint，设置为Local只会路由到当前节点上就绪的Endpoint。如果流量策略是Local，而当前节点上没有就绪的Endpoint，那么 kube-proxy 会丢弃流量。\n服务发现 Kubernetes 支持两种基本的服务发现模式 —— 环境变量和 DNS。\n环境变量: Pod创建的时候，服务的ip和port等信息会以环境变量的形式注入到pod里 DNS: Service创建成功后，会在dns服务器里导入一些记录，想要访问某个服务，通过dns服务器解析出对应的ip和port，从而实现服务访问 基于环境变量服务发现 当 Pod 运行在 Node 上，kubelet 会为每个活跃的 Service 添加一组环境变量。 支持 {SVCNAME}_SERVICE_HOST 和 {SVCNAME}_SERVICE_PORT 等变量。这里 Service 的名称需大写，横线被转换成下划线。\n例如有一个名称为 nginx-service 的 Service 暴露了 TCP 端口8180，同时给它分配了Cluster IP地址 10.96.0.11，这个 Service 生成了如下环境变量：\nNGINX_SERVICE_SERVICE_HOST=10.96.0.11 NGINX_SERVICE_PORT_8180_TCP_ADDR=10.96.0.11 KUBERNETES_PORT_443_TCP_PROTO=tcp NGINX_SERVICE_PORT_8180_TCP_PORT=8180 NGINX_SERVICE_PORT_8180_TCP_PROTO=tcp NGINX_SERVICE_SERVICE_PORT=8180 NGINX_SERVICE_PORT=tcp://10.96.0.11:8180 NGINX_SERVICE_PORT_8180_TCP=tcp://10.96.0.11:8180 # 实例 [root@k8s-master01 ~]# mkdir network [root@k8s-master01 ~]# cd network/ [root@k8s-master01 network]# vim nginx-deploy.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deploy labels: app: nginx spec: replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.18.0 ports: - containerPort: 80 # 配置Service [root@k8s-master01 network]# vim nginx-service.yaml apiVersion: v1 kind: Service metadata: name: nginx-service labels: name: nginx-service spec: ports: - port: 8180 targetPort: 80 selector: app: nginx [root@k8s-master01 network]# kubectl apply -f nginx-deploy.yaml deployment.apps/nginx-deploy created [root@k8s-master01 network]# kubectl apply -f nginx-service.yaml service/nginx-service created [root@k8s-master01 network]# kubectl get deployments.apps,svc NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/nginx-deploy 2/2 2 2 40s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/nginx-service ClusterIP 10.105.254.62 8180/TCP 33s [root@k8s-master01 network]# kubectl get po NAME READY STATUS RESTARTS AGE busybox 1/1 Running 3 (38m ago) 4h46m look-svc-env 0/1 Completed 0 18s [root@k8s-master01 network]# vim look-svc-env.yaml apiVersion: v1 kind: Pod metadata: name: look-svc-env spec: containers: - name: look-svc-env image: busybox command: [\"/bin/sh\", \"-c\", \"env\"] [root@k8s-master01 network]# kubectl apply -f look-svc-env.yaml pod/look-svc-env created # 可以查看到nginx-service环境变量已经写入 [root@k8s-master01 network]# kubectl logs look-svc-env KUBERNETES_PORT=tcp://10.96.0.1:443 KUBERNETES_SERVICE_PORT=443 HOSTNAME=look-svc-env SHLVL=1 HOME=/root KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin NGINX_SERVICE_SERVICE_HOST=10.105.254.62 KUBERNETES_PORT_443_TCP_PORT=443 NGINX_SERVICE_PORT_8180_TCP_ADDR=10.105.254.62 KUBERNETES_PORT_443_TCP_PROTO=tcp NGINX_SERVICE_PORT_8180_TCP_PORT=8180 NGINX_SERVICE_PORT_8180_TCP_PROTO=tcp NGINX_SERVICE_PORT=tcp://10.105.254.62:8180 NGINX_SERVICE_SERVICE_PORT=8180 KUBERNETES_SERVICE_PORT_HTTPS=443 KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443 KUBERNETES_SERVICE_HOST=10.96.0.1 PWD=/ NGINX_SERVICE_PORT_8180_TCP=tcp://10.105.254.62:8180 # nginx-service停掉后，nginx-service相关的环境变量消失 基于DNS服务发现 支持集群的 DNS 服务器（例如 CoreDNS）监视 Kubernetes API 中的Service，并为每个Service创建一组 DNS 记录。如果在整个集群中都启用了DNS，则所有 Pod 都应该能够通过其 DNS 名称自动解析服务。\n例如，如果你在 Kubernetes 命名空间my-ns中有一个名为my-service的Service，则控制节点和DNS服务共同为my-service.my-ns创建DNS记录。my-ns命名空间中的Pod可以直接用名称my-service来找到服务（当然使用my-service.my-ns也可以）。\nKubernetes 从 v1.11 开始可以使用 CoreDNS 来提供命名服务，并从 v1.13 开始成为默认 DNS 服务。CoreDNS 的特点是效率更高，资源占用率更小，推荐使用 CoreDNS 替代 kube-dns 为集群提供 DNS 服务。CoreDNS基本架构如下:\n如果需要定制DNS服务,可参考下面官方给的方案:https://kubernetes.io/zh/docs/tasks/administer-cluster/dns-custom-nameservers/\nPod DNS DNS策略可以逐个Pod来设定。目前 Kubernetes 支持以下特定 Pod 的 DNS 策略。这些策略可以在Pod的spec.dnsPolicy字段设置：\n“Default”: Pod 从运行所在的节点继承名称解析配置 “ClusterFirst”: 与配置的集群域后缀不匹配的任何 DNS 查询（例如 “www.kubernetes.io”） 都将转发到从节点继承的上游名称服务器。集群管理员可能配置了额外的存根域和上游 DNS 服务器 “ClusterFirstWithHostNet”：对于以 hostNetwork 方式运行的 Pod，应显式设置其 DNS 策略 “ClusterFirstWithHostNet” “None”: 此设置允许 Pod 忽略 Kubernetes 环境中的 DNS 设置。Pod 会使用其dnsConfig字段所提供的 DNS 设置 说明： “Default” 不是默认的 DNS 策略。如果未明确指定 dnsPolicy，则使用 “ClusterFirst”。\nPod 的 DNS 配置可让用户对 Pod 的 DNS 设置进行更多控制。\ndnsConfig 字段是可选的，它可以与任何 dnsPolicy 设置一起使用。 但是，当 Pod 的 dnsPolicy 设置为 “None” 时，必须指定 dnsConfig 字段。\n用户可以在 dnsConfig 字段中指定以下属性：\nnameservers：将用作于 Pod 的 DNS 服务器的 IP 地址列表。 最多可以指定 3 个 IP 地址。当 Pod 的 dnsPolicy 设置为 “None” 时， 列表必须至少包含一个 IP 地址，否则此属性是可选的 searches：用于在 Pod 中查找主机名的 DNS 搜索域的列表。此属性是可选的, Kubernetes 最多允许 6 个搜索域 options：可选的对象列表，其中每个对象可能具有 name 属性（必需）和 value 属性（可选） # 创建自定义DNS的Pod [root@k8s-master01 network]# vim pod_dns.yaml apiVersion: v1 kind: Pod metadata: name: nginx labels: app: nginx spec: containers: - name: nginx image: nginx:1.18.0 ports: - containerPort: 80 dnsPolicy: \"None\" dnsConfig: nameservers: - 8.8.8.8 searches: - default.svc.cluster-domain.example - cluster-domain.example options: - name: pod_num value: \"1\" [root@k8s-master01 network]# kubectl apply -f pod_dns.yaml pod/nginx created # 查看DNS信息 [root@k8s-master01 network]# kubectl exec nginx -- cat /etc/resolv.conf nameserver 8.8.8.8 search default.svc.cluster-domain.example cluster-domain.example options pod_num:1 # Pod访问验证 # 创建Service来暴露Pod [root@k8s-master01 network]# cat nginx-service.yaml apiVersion: v1 kind: Service metadata: name: nginx-service labels: name: nginx-service spec: ports: - port: 8180 targetPort: 80 selector: app: nginx [root@k8s-master01 network]# kubectl apply -f nginx-service.yaml service/nginx-service created [root@k8s-master01 network]# kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE nginx-service ClusterIP 10.97.188.44 8180/TCP 75s [root@k8s-master01 network]# kubectl exec busybox -- nslookup 10.97.188.44 Server: 10.96.0.10 Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local Name: 10.97.188.44 Address 1: 10.97.188.44 nginx-service.default.svc.cluster.local [root@k8s-master01 network]# kubectl exec busybox -- wget -q -O- nginx-service.default.svc.cluster.local:8180 \u003c!DOCTYPE html\u003e Welcome to nginx! Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required.\nFor online documentation and support please refer to ",
  "wordCount" : "6047",
  "inLanguage": "en",
  "image":"https://deemoprobe.github.io/img/kubernetes.png","datePublished": "2023-04-30T02:26:47+08:00",
  "dateModified": "2023-04-30T02:26:47+08:00",
  "author":[{
    "@type": "Person",
    "name": "deemoprobe"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://deemoprobe.github.io/posts/tech/kubernetes/kubernetesservicediscovery/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "William's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://deemoprobe.github.io/img/bear.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    (function () {
        let  arr,reg = new RegExp("(^| )"+"change-themes"+"=([^;]*)(;|$)");
        if(arr = document.cookie.match(reg)) {
        } else {
            if (new Date().getHours() >= 19 || new Date().getHours() < 6) {
                document.body.classList.add('dark');
                localStorage.setItem("pref-theme", 'dark');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem("pref-theme", 'light');
            }
        }
    })()

    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://deemoprobe.github.io/" accesskey="h" title="William&#39;s Blog (Alt + H)">
            <img src="https://deemoprobe.github.io/img/bear.gif" alt="logo" aria-label="logo"
                 height="35">William&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                         fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                         stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://deemoprobe.github.io/" title="🏠 主页">
                <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://deemoprobe.github.io/tags" title="🎨 标签">
                <span>🎨 标签</span>
                </a>
            </li>
            <li>
                <a href="https://deemoprobe.github.io/archives/" title="📈 归档">
                <span>📈 归档</span>
                </a>
            </li>
            <li>
                <a href="https://deemoprobe.github.io/tools" title="🪁 工具">
                <span>🪁 工具</span>
                </a>
            </li>
            <li>
                <a href="https://deemoprobe.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                <span>🔍 搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main page">
<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }
</style>

<article class="post-single">
    <div id="single-content">
        <header class="post-header">
            
            <h1 class="post-title">
                KubernetesServiceDiscovery
            </h1>
            <div class="post-description">
                Kubernetes Service和服务发现
            </div>
            <div class="post-meta">

<style>
    i[id*="post_meta_style"] {
        display: flex;
        align-items: center;
        margin: 0 0 10px 0;
    }

    .parent-post-meta {
        display: flex;
        flex-wrap: wrap;
        opacity: 0.8;
    }
</style>

<span class="parent-post-meta">
    <span id="post_meta_style_1">
        <span class="fa fa-calendar-check-o"></span>
        <span>2023-04-30
            &nbsp;&nbsp;
        </span>
    </span>
    
    
    
    
    
    
    
    <span id="post_meta_style_3">
        <span class="fa fa-file-word-o"></span>
        <span>6047字
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_4">
        <span class="fa fa-clock-o"></span>
        <span>13分钟
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_5">
        <span class="fa fa-user-o"></span>
        <span>deemoprobe
            &nbsp;&nbsp;
        </span>
    </span>
    <span id="post_meta_style_6">
        <span class="fa fa-tags" style="opacity: 0.8"></span>
        <span>
            <span class="post-tags-meta">
                <a href="https://deemoprobe.github.io/tags/kubernetes/" style="color: var(--secondary)!important;">kubernetes</a>
            </span>
        </span>
    </span>
</span>
<span style="opacity: 0.8;">
                    <span id="post_meta_style_7">
                        &nbsp;&nbsp;
                        <span class="fa fa-eye" ></span>
                        <span>
                            <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
                            &nbsp;&nbsp;
                        </span>
                    </span>
                    
                </span>

</div>
        </header> 
<figure class="entry-cover1"><img style="zoom:;" loading="lazy" src="https://deemoprobe.github.io/img/kubernetes.png" alt="">
    
</figure><aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">文章目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%ae%9a%e4%b9%89" aria-label="定义">定义</a></li>
                <li>
                    <a href="#headless-service" aria-label="Headless Service">Headless Service</a></li>
                <li>
                    <a href="#service%e5%8f%91%e5%b8%83%e7%b1%bb%e5%9e%8b" aria-label="Service发布类型">Service发布类型</a></li>
                <li>
                    <a href="#%e5%a4%96%e9%83%a8ip" aria-label="外部IP">外部IP</a></li>
                <li>
                    <a href="#service%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f" aria-label="Service代理模式">Service代理模式</a><ul>
                        
                <li>
                    <a href="#iptables%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f" aria-label="iptables代理模式">iptables代理模式</a></li>
                <li>
                    <a href="#ipvs%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f" aria-label="IPVS代理模式">IPVS代理模式</a></li>
                <li>
                    <a href="#%e9%80%89%e6%8b%a9%e5%90%88%e9%80%82%e7%9a%84%e6%a8%a1%e5%bc%8f" aria-label="选择合适的模式">选择合适的模式</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%b5%81%e9%87%8f%e8%bd%ac%e5%8f%91%e7%ad%96%e7%95%a5" aria-label="流量转发策略">流量转发策略</a><ul>
                        
                <li>
                    <a href="#%e5%a4%96%e9%83%a8%e6%b5%81%e9%87%8f" aria-label="外部流量">外部流量</a></li>
                <li>
                    <a href="#%e5%86%85%e9%83%a8%e6%b5%81%e9%87%8f" aria-label="内部流量">内部流量</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0" aria-label="服务发现">服务发现</a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0" aria-label="基于环境变量服务发现">基于环境变量服务发现</a></li>
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8edns%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0" aria-label="基于DNS服务发现">基于DNS服务发现</a><ul>
                        
                <li>
                    <a href="#pod-dns" aria-label="Pod DNS">Pod DNS</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
        
        activeElement = elements[0];
        const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
        document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
    }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 &&
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
            const id = encodeURI(element.getAttribute('id')).toLowerCase();
            if (element === activeElement){
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
            } else {
                document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
            }
        })
    }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;
        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;
    }
</script>
        <div class="post-content"><p>Service是一种Pod的服务暴露机制，其他Pod可以通过这个Service访问到这个Service代理的一个或一组Pod。</p>
<p>带有selector的Service在创建后会同时创建一个同名的Endpoints实例，Endpoints实例记录了selector匹配的Pod的IP地址和端口。当Pod被重建后，Endpoints会被更新，而我们使用Service名称连接后端Pod，IP变动不会对服务造成影响。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 集群初始化后的Service和Endpoint</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 yamls<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl get svc | grep kubernetes</span>
</span></span><span style="display:flex;"><span>kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   8d
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 yamls<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl get ep | grep kubernetes</span>
</span></span><span style="display:flex;"><span>kubernetes   192.168.43.201:6443,192.168.43.202:6443,192.168.43.203:6443   8d
</span></span></code></pre></div><h2 id="定义">定义<a hidden class="anchor" aria-hidden="true" href="#定义">#</a></h2>
<p>假设存在一个或一组打有&quot;app=myapp&quot;标签的pod，Pod对外暴露的端口是8001，那么可以创建Service去代理这些Pod</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 单个端口代理示例</span>
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Service
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: my-service
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  selector:
</span></span><span style="display:flex;"><span>    app: myapp         <span style="color:#75715e"># 选择带有该标签的Pod</span>
</span></span><span style="display:flex;"><span>  ports:
</span></span><span style="display:flex;"><span>    - protocol: TCP    <span style="color:#75715e"># UDP TCP SCTP default: TCP</span>
</span></span><span style="display:flex;"><span>      port: <span style="color:#ae81ff">8080</span>       <span style="color:#75715e"># Service自己的端口</span>
</span></span><span style="display:flex;"><span>      targetPort: <span style="color:#ae81ff">8001</span> <span style="color:#75715e"># 后端应用Pod暴露的端口</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># name: http     # Service端口的名称</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 多个端口代理示例</span>
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Service
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: my-service
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  selector:
</span></span><span style="display:flex;"><span>    app: myapp
</span></span><span style="display:flex;"><span>  ports:
</span></span><span style="display:flex;"><span>    - name: http
</span></span><span style="display:flex;"><span>      protocol: TCP
</span></span><span style="display:flex;"><span>      port: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>      targetPort: <span style="color:#ae81ff">8001</span>
</span></span><span style="display:flex;"><span>    - name: https
</span></span><span style="display:flex;"><span>      protocol: TCP
</span></span><span style="display:flex;"><span>      port: <span style="color:#ae81ff">443</span>
</span></span><span style="display:flex;"><span>      targetPort: <span style="color:#ae81ff">8002</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 无selector的Service</span>
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Service
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: my-service
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  ports:
</span></span><span style="display:flex;"><span>    - protocol: TCP
</span></span><span style="display:flex;"><span>	  port: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>	  targetPort: <span style="color:#ae81ff">8001</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 由于没有selector，该Service创建后不会自动创建Endpoints实例，需要手动创建</span>
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Endpoints
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: my-service
</span></span><span style="display:flex;"><span>  subnets:
</span></span><span style="display:flex;"><span>    - addresses:
</span></span><span style="display:flex;"><span>	    - ip: 1.2.3.4
</span></span><span style="display:flex;"><span>	  ports:
</span></span><span style="display:flex;"><span>	    - port: <span style="color:#ae81ff">8001</span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ExternalName Service，没有selector没有Endpoints，仅使用别名解析Service</span>
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Service
</span></span><span style="display:flex;"><span>metadata: 
</span></span><span style="display:flex;"><span>  name: my-service
</span></span><span style="display:flex;"><span>  namespace: dev
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  type: ExternalName
</span></span><span style="display:flex;"><span>  externalName: my.nginx.example.com
</span></span></code></pre></div><blockquote>
<p>说明：Service 能够将一个接收 port 映射到任意的 targetPort。 默认情况下，targetPort 将被设置为与 port 字段相同的值。</p>
</blockquote>
<h2 id="headless-service">Headless Service<a hidden class="anchor" aria-hidden="true" href="#headless-service">#</a></h2>
<p>有时不需要或不想要负载均衡，以及单独的 Service IP。可以通过指定spec下面的<code>clusterIP: None</code>来创建 Headless Service。</p>
<p>无头服务并不会分配 Cluster IP，kube-proxy 不会处理它们，而且平台也不会为它们进行负载均衡和路由。DNS如何实现自动配置，依赖于 Service 是否定义了<code>selector</code>。</p>
<p>对于定义了<code>selector</code>的无头服务，Endpoint 控制器在 API 中创建了 Endpoints 记录，并且修改 DNS 配置返回 A 记录（IP 地址），通过这个地址直接到达 Service 的后端 Pod 上。</p>
<p>对于没有定义<code>selector</code>的无头服务，Endpoint 控制器不会创建 Endpoints 记录。DNS系统会查找和配置：</p>
<ul>
<li>对于 ExternalName 类型的服务，查找其 CNAME 记录</li>
<li>对所有其他类型的服务，查找与 Service 名称相同的任何 Endpoints 的记录</li>
</ul>
<h2 id="service发布类型">Service发布类型<a hidden class="anchor" aria-hidden="true" href="#service发布类型">#</a></h2>
<p>Kubernetes 允许指定你所需要的 Service 类型，默认是 ClusterIP，可以自定义<code>spec</code>字段下的<code>type</code>字段。<code>type</code>的取值以及行为如下：</p>
<ul>
<li><code>ClusterIP</code>：通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。</li>
<li><code>NodePort</code>：通过每个节点上的 IP 和静态端口（NodePort）暴露服务。NodePort服务会路由到自动创建的ClusterIP服务。通过请求<code>&lt;节点 IP&gt;:&lt;节点端口&gt;</code>，NodePort端口范围默认是30000-32767。可以从集群的外部访问。</li>
<li><code>LoadBalancer</code>：使用云提供商的负载均衡器向外部暴露服务。外部负载均衡器可以将流量路由到自动创建的NodePort服务和ClusterIP服务上。</li>
<li><code>ExternalName</code>：通过返回CNAME（别名）和对应值，可以将服务映射到 externalName 字段的内容（例如，foo.bar.example.com）。无需创建任何类型代理。</li>
</ul>
<blockquote>
<p>说明：kube-dns 1.7 及以上版本或者 CoreDNS 0.0.8 及以上版本才能使用 ExternalName 类型。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># ClusterIP类型，type可以不指定</span>
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Service
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: my-service
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  selector:
</span></span><span style="display:flex;"><span>    app: myapp
</span></span><span style="display:flex;"><span>  ports:
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># 默认情况下，为了方便起见，`targetPort` 被设置为与 `port` 字段相同的值。</span>
</span></span><span style="display:flex;"><span>    - port: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>      targetPort: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># NodePort类型</span>
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Service
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: my-service
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  type: NodePort
</span></span><span style="display:flex;"><span>  selector:
</span></span><span style="display:flex;"><span>    app: myapp
</span></span><span style="display:flex;"><span>  ports:
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># 默认情况下，为了方便起见，`targetPort` 被设置为与 `port` 字段相同的值。</span>
</span></span><span style="display:flex;"><span>    - port: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>      targetPort: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e"># 可选字段，不指定的话会自动设置为30000-32767中的一个</span>
</span></span><span style="display:flex;"><span>      nodePort: <span style="color:#ae81ff">30007</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># LoadBalancer类型，status.loadBalancer字段指定云厂商提供的负载均衡地址</span>
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Service
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: my-service
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  selector:
</span></span><span style="display:flex;"><span>    app: MyApp
</span></span><span style="display:flex;"><span>  ports:
</span></span><span style="display:flex;"><span>    - protocol: TCP
</span></span><span style="display:flex;"><span>      port: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>      targetPort: <span style="color:#ae81ff">8001</span>
</span></span><span style="display:flex;"><span>  clusterIP: 10.96.0.239
</span></span><span style="display:flex;"><span>  type: LoadBalancer
</span></span><span style="display:flex;"><span>status:
</span></span><span style="display:flex;"><span>  loadBalancer:
</span></span><span style="display:flex;"><span>    ingress:
</span></span><span style="display:flex;"><span>      - ip: 192.0.2.127
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ExternalName类型</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 访问nginx-externalname.test.svc.cluster.local被重定向到www.baidu.com</span>
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Service
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  labels:
</span></span><span style="display:flex;"><span>    app: nginx-externalname
</span></span><span style="display:flex;"><span>  name: nginx-externalname
</span></span><span style="display:flex;"><span>  namespace: test
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  type: ExternalName
</span></span><span style="display:flex;"><span>  externalName: www.baidu.com
</span></span></code></pre></div><h2 id="外部ip">外部IP<a hidden class="anchor" aria-hidden="true" href="#外部ip">#</a></h2>
<p>如果外部IP路由到集群中一个或多个Node上，Kubernetes Service 会被暴露给这些<code>externalIP</code>。通过外部 IP（作为目的 IP 地址）进入到集群，流量将会被路由到 Service 的 Endpoint 上。根据 Service 的规定，externalIPs 可以同任意的 ServiceType 来一起指定。 在下面的例子中，my-service 可以通过 &ldquo;80.11.12.10:80&rdquo;(externalIP:port)被客户端访问。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Service
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: my-service
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  selector:
</span></span><span style="display:flex;"><span>    app: myapp
</span></span><span style="display:flex;"><span>  ports:
</span></span><span style="display:flex;"><span>    - name: http
</span></span><span style="display:flex;"><span>      protocol: TCP
</span></span><span style="display:flex;"><span>      port: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>      targetPort: <span style="color:#ae81ff">8001</span>
</span></span><span style="display:flex;"><span>  externalIPs:
</span></span><span style="display:flex;"><span>    - 80.11.12.10
</span></span></code></pre></div><h2 id="service代理模式">Service代理模式<a hidden class="anchor" aria-hidden="true" href="#service代理模式">#</a></h2>
<p>在 Kubernetes 集群中，<code>kube-proxy</code>负责为Service实现了一种VIP形式的代理，而不是<code>ExternalName</code>的形式。这种VIP形式的代理主要有下面两种实现方式，现在kubernetes推荐使用ipvs</p>
<h3 id="iptables代理模式">iptables代理模式<a hidden class="anchor" aria-hidden="true" href="#iptables代理模式">#</a></h3>
<p>在iptables模式中，kube-proxy 监视 Kubernetes的Service和Endpoints的状态变化（创建或删除），对每个 Service它都会创建<code>iptables</code>规则，从而捕获到达该 Service 的<code>ClusterIP</code>和端口的请求，进而将请求重定向到 Service 后端中的某个 Pod 上面。 对于每个 Endpoints 对象，它也会创建<code>iptables</code>规则，这个规则会选择一个后端pod。</p>
<p>默认的策略是，kube-proxy 在 iptables 模式下随机选择一个后端。如果要确保每次都将来自特定客户端的连接传递到同一Pod（即会话保持），则可以通过设置亲和力调度策略<code>service.spec.sessionAffinity: ClientIP</code>（默认值是 <code>None</code>），来基于客户端的 IP 地址选择会话关联。还可以通过设置<code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code>来配置最大会话停留时间。（默认值为 10800 秒，即 3 小时）</p>
<h3 id="ipvs代理模式">IPVS代理模式<a hidden class="anchor" aria-hidden="true" href="#ipvs代理模式">#</a></h3>
<p>在ipvs模式中，kube-proxy 监视 Kubernetes的Service和Endpoints的状态变化（创建或删除），调用<code>netlink</code>接口创建 IPVS 规则，并定期将规则与Kubernetes的Service和Endpoints同步。确保IPVS状态与所需状态匹配。访问服务时，IPVS根据规则将流量定向到后端Pod之一</p>
<p>类似iptables，IPVS基于<code>netfilter</code>钩子函数，但是使用哈希表作为基础数据结构，在内核空间中工作，内核级的转发，所以速度很快。</p>
<p>IPVS 提供以下选项来实现负载均衡：</p>
<ul>
<li><code>rr</code>：轮询（Round-Robin）</li>
<li><code>lc</code>：最少链接（Least Connection），即打开链接数量最少者优先</li>
<li><code>dh</code>：目标地址哈希（Destination Hashing）</li>
<li><code>sh</code>：源地址哈希（Source Hashing）</li>
<li><code>sed</code>：最短预期延迟（Shortest Expected Delay）</li>
<li><code>nq</code>：从不排队（Never Queue）</li>
</ul>
<blockquote>
<p>说明：要在 IPVS 模式下运行 kube-proxy，必须在启动 kube-proxy 之前使 IPVS 在节点上可用（启用IPVS可以参考<a href="https://deemoprobe.github.io/posts/tech/kubernetesbinaryinstallation-ha/#%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9call"  target="_blank" rel="noopener" style="color:#42b983" ;>高可用集群安装文档</a> 当kube-proxy 以 IPVS 代理模式启动时，它将验证 IPVS 内核模块是否可用。 如果未检测到 IPVS 内核模块，则 kube-proxy 将退回到以 iptables 代理模式运行。</p>
</blockquote>
<p><img loading="lazy" src="https://deemoprobe.oss-cn-shanghai.aliyuncs.com/images/20220119161939.png" alt="20220119161939"  />
</p>
<h3 id="选择合适的模式">选择合适的模式<a hidden class="anchor" aria-hidden="true" href="#选择合适的模式">#</a></h3>
<p>iptables由于线性查找匹配、全量更新等特点，当规则很多时，性能会比ipvs差，所以一般推荐选择ipvs</p>
<p><code>iptables</code>工具基于Linux内核的<code>Netfilter</code>模块，默认定义了多张表。每张表里包含若干内置链（chain），也可能包含用户自定义的链。每条链是一套规则（rule）列表，用于匹配一组数据包。每条规则都指定如何处理匹配的数据包。</p>
<ul>
<li>
<p>table：包含一组chain的表</p>
</li>
<li>
<p>chain：包含一组rule的链</p>
</li>
<li>
<p>rule：匹配数据包的规则，例如：协议，端口号</p>
</li>
<li>
<p>target：规则中的具体行为，例如：ACCEPT，DROP，INPUT，FORWARD，OUTPUT</p>
</li>
<li>
<p>表</p>
<ul>
<li>filter：默认表，通用数据包过滤表</li>
<li>mangle：为特定的数据包设计</li>
<li>nat：针对创建新连接的数据包</li>
<li>raw：主要用于结合 NOTRACK target 配置连接跟踪的豁免</li>
<li>security：用于MAC（Mandatory Access Control，强制访问控制）规则</li>
</ul>
</li>
<li>
<p>规则链</p>
<ul>
<li>INPUT：以本机为目标的入口数据包规则链</li>
<li>OUTPUT：本机产生，向外转发的数据包规则链</li>
<li>FORWARD：路由经过本机的数据包规则链</li>
<li>PREROUTING：数据包进入路由之前的规则链</li>
<li>POSTROUTING：数据包发送到目标前（出路由）的规则链</li>
</ul>
</li>
</ul>
<p>IPtables处理链接的算法复杂度为O(n)，IPVS为O(1)，Service规模在1000内二者差距并不是很大。在Service规模超过1000后，IPtables规则链达到2000以上，性能开始下降，响应时间成倍数增加，IPVS则几乎不受Service规模的影响。Calico虽然也采用IPtables技术，但对规则链进行了优化，算法复杂度也达到了了O(1)的水平。除了大规模服务性能的差距，IPVS还具备复杂均衡算法全（轮询、最小连接数、哈希值、最小延迟等）、支持健康检查等优点。</p>
<p><img loading="lazy" src="https://deemoprobe.oss-cn-shanghai.aliyuncs.com/images/IPVSvsIPtables.png" alt="IPVSvsIPtables"  />
</p>
<h2 id="流量转发策略">流量转发策略<a hidden class="anchor" aria-hidden="true" href="#流量转发策略">#</a></h2>
<h3 id="外部流量">外部流量<a hidden class="anchor" aria-hidden="true" href="#外部流量">#</a></h3>
<p>可以通过设置<code>spec.externalTrafficPolicy</code>字段来控制来自于外部的流量是如何路由的。可选值有<code>Cluster</code>和<code>Local</code>。字段设为<code>Cluster</code>会将外部流量路由到所有就绪的Endpoint，设为<code>Local</code>只会路由到当前节点上就绪的Endpoint。如果流量策略设置为<code>Local</code>，而当前节点上没有就绪的Endpoint，kube-proxy不会转发请求相关服务的任何流量。</p>
<h3 id="内部流量">内部流量<a hidden class="anchor" aria-hidden="true" href="#内部流量">#</a></h3>
<p>可以通过设置<code>spec.internalTrafficPolicy</code>字段来控制内部来源的流量是如何转发的。可设置的值有<code>Cluster</code>和<code>Local</code>。将字段设置为<code>Cluster</code>会将内部流量路由到所有就绪Endpoint，设置为<code>Local</code>只会路由到当前节点上就绪的Endpoint。如果流量策略是<code>Local</code>，而当前节点上没有就绪的Endpoint，那么 kube-proxy 会丢弃流量。</p>
<h2 id="服务发现">服务发现<a hidden class="anchor" aria-hidden="true" href="#服务发现">#</a></h2>
<p>Kubernetes 支持两种基本的服务发现模式 —— 环境变量和 DNS。</p>
<ul>
<li>环境变量: Pod创建的时候，服务的ip和port等信息会以环境变量的形式注入到pod里</li>
<li>DNS: Service创建成功后，会在dns服务器里导入一些记录，想要访问某个服务，通过dns服务器解析出对应的ip和port，从而实现服务访问</li>
</ul>
<h3 id="基于环境变量服务发现">基于环境变量服务发现<a hidden class="anchor" aria-hidden="true" href="#基于环境变量服务发现">#</a></h3>
<p>当 Pod 运行在 Node 上，kubelet 会为每个活跃的 Service 添加一组环境变量。 支持 {SVCNAME}_SERVICE_HOST 和 {SVCNAME}_SERVICE_PORT 等变量。这里 Service 的名称需大写，横线被转换成下划线。</p>
<p>例如有一个名称为 nginx-service 的 Service 暴露了 TCP 端口8180，同时给它分配了<code>Cluster IP</code>地址 10.96.0.11，这个 Service 生成了如下环境变量：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>NGINX_SERVICE_SERVICE_HOST<span style="color:#f92672">=</span>10.96.0.11
</span></span><span style="display:flex;"><span>NGINX_SERVICE_PORT_8180_TCP_ADDR<span style="color:#f92672">=</span>10.96.0.11
</span></span><span style="display:flex;"><span>KUBERNETES_PORT_443_TCP_PROTO<span style="color:#f92672">=</span>tcp
</span></span><span style="display:flex;"><span>NGINX_SERVICE_PORT_8180_TCP_PORT<span style="color:#f92672">=</span><span style="color:#ae81ff">8180</span>
</span></span><span style="display:flex;"><span>NGINX_SERVICE_PORT_8180_TCP_PROTO<span style="color:#f92672">=</span>tcp
</span></span><span style="display:flex;"><span>NGINX_SERVICE_SERVICE_PORT<span style="color:#f92672">=</span><span style="color:#ae81ff">8180</span>
</span></span><span style="display:flex;"><span>NGINX_SERVICE_PORT<span style="color:#f92672">=</span>tcp://10.96.0.11:8180
</span></span><span style="display:flex;"><span>NGINX_SERVICE_PORT_8180_TCP<span style="color:#f92672">=</span>tcp://10.96.0.11:8180
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 实例</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># mkdir network</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 ~<span style="color:#f92672">]</span><span style="color:#75715e"># cd network/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># vim nginx-deploy.yaml</span>
</span></span><span style="display:flex;"><span>apiVersion: apps/v1
</span></span><span style="display:flex;"><span>kind: Deployment
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: nginx-deploy
</span></span><span style="display:flex;"><span>  labels:
</span></span><span style="display:flex;"><span>    app: nginx
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  replicas: <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>  selector:
</span></span><span style="display:flex;"><span>    matchLabels:
</span></span><span style="display:flex;"><span>      app: nginx
</span></span><span style="display:flex;"><span>  template:
</span></span><span style="display:flex;"><span>    metadata:
</span></span><span style="display:flex;"><span>      labels:
</span></span><span style="display:flex;"><span>        app: nginx
</span></span><span style="display:flex;"><span>    spec:
</span></span><span style="display:flex;"><span>      containers:
</span></span><span style="display:flex;"><span>      - name: nginx
</span></span><span style="display:flex;"><span>        image: nginx:1.18.0
</span></span><span style="display:flex;"><span>        ports:
</span></span><span style="display:flex;"><span>        - containerPort: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 配置Service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># vim nginx-service.yaml</span>
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Service
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: nginx-service
</span></span><span style="display:flex;"><span>  labels:
</span></span><span style="display:flex;"><span>    name: nginx-service
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  ports:
</span></span><span style="display:flex;"><span>  - port: <span style="color:#ae81ff">8180</span>
</span></span><span style="display:flex;"><span>    targetPort: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>  selector:
</span></span><span style="display:flex;"><span>    app: nginx
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl apply -f nginx-deploy.yaml</span>
</span></span><span style="display:flex;"><span>deployment.apps/nginx-deploy created
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl apply -f nginx-service.yaml</span>
</span></span><span style="display:flex;"><span>service/nginx-service created
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl get deployments.apps,svc</span>
</span></span><span style="display:flex;"><span>NAME                           READY   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style="display:flex;"><span>deployment.apps/nginx-deploy   2/2     <span style="color:#ae81ff">2</span>            <span style="color:#ae81ff">2</span>           40s
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NAME                    TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span style="color:#f92672">(</span>S<span style="color:#f92672">)</span>    AGE
</span></span><span style="display:flex;"><span>service/nginx-service   ClusterIP   10.105.254.62   &lt;none&gt;        8180/TCP   33s
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl get po</span>
</span></span><span style="display:flex;"><span>NAME                           READY   STATUS      RESTARTS      AGE
</span></span><span style="display:flex;"><span>busybox                        1/1     Running     <span style="color:#ae81ff">3</span> <span style="color:#f92672">(</span>38m ago<span style="color:#f92672">)</span>   4h46m
</span></span><span style="display:flex;"><span>look-svc-env                   0/1     Completed   <span style="color:#ae81ff">0</span>             18s
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># vim look-svc-env.yaml</span>
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Pod
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: look-svc-env
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  containers:
</span></span><span style="display:flex;"><span>  - name: look-svc-env
</span></span><span style="display:flex;"><span>    image: busybox
</span></span><span style="display:flex;"><span>    command: <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;/bin/sh&#34;</span>, <span style="color:#e6db74">&#34;-c&#34;</span>, <span style="color:#e6db74">&#34;env&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl apply -f look-svc-env.yaml </span>
</span></span><span style="display:flex;"><span>pod/look-svc-env created
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 可以查看到nginx-service环境变量已经写入</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl logs look-svc-env </span>
</span></span><span style="display:flex;"><span>KUBERNETES_PORT<span style="color:#f92672">=</span>tcp://10.96.0.1:443
</span></span><span style="display:flex;"><span>KUBERNETES_SERVICE_PORT<span style="color:#f92672">=</span><span style="color:#ae81ff">443</span>
</span></span><span style="display:flex;"><span>HOSTNAME<span style="color:#f92672">=</span>look-svc-env
</span></span><span style="display:flex;"><span>SHLVL<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>HOME<span style="color:#f92672">=</span>/root
</span></span><span style="display:flex;"><span>KUBERNETES_PORT_443_TCP_ADDR<span style="color:#f92672">=</span>10.96.0.1
</span></span><span style="display:flex;"><span>PATH<span style="color:#f92672">=</span>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
</span></span><span style="display:flex;"><span>NGINX_SERVICE_SERVICE_HOST<span style="color:#f92672">=</span>10.105.254.62
</span></span><span style="display:flex;"><span>KUBERNETES_PORT_443_TCP_PORT<span style="color:#f92672">=</span><span style="color:#ae81ff">443</span>
</span></span><span style="display:flex;"><span>NGINX_SERVICE_PORT_8180_TCP_ADDR<span style="color:#f92672">=</span>10.105.254.62
</span></span><span style="display:flex;"><span>KUBERNETES_PORT_443_TCP_PROTO<span style="color:#f92672">=</span>tcp
</span></span><span style="display:flex;"><span>NGINX_SERVICE_PORT_8180_TCP_PORT<span style="color:#f92672">=</span><span style="color:#ae81ff">8180</span>
</span></span><span style="display:flex;"><span>NGINX_SERVICE_PORT_8180_TCP_PROTO<span style="color:#f92672">=</span>tcp
</span></span><span style="display:flex;"><span>NGINX_SERVICE_PORT<span style="color:#f92672">=</span>tcp://10.105.254.62:8180
</span></span><span style="display:flex;"><span>NGINX_SERVICE_SERVICE_PORT<span style="color:#f92672">=</span><span style="color:#ae81ff">8180</span>
</span></span><span style="display:flex;"><span>KUBERNETES_SERVICE_PORT_HTTPS<span style="color:#f92672">=</span><span style="color:#ae81ff">443</span>
</span></span><span style="display:flex;"><span>KUBERNETES_PORT_443_TCP<span style="color:#f92672">=</span>tcp://10.96.0.1:443
</span></span><span style="display:flex;"><span>KUBERNETES_SERVICE_HOST<span style="color:#f92672">=</span>10.96.0.1
</span></span><span style="display:flex;"><span>PWD<span style="color:#f92672">=</span>/
</span></span><span style="display:flex;"><span>NGINX_SERVICE_PORT_8180_TCP<span style="color:#f92672">=</span>tcp://10.105.254.62:8180
</span></span><span style="display:flex;"><span><span style="color:#75715e"># nginx-service停掉后，nginx-service相关的环境变量消失</span>
</span></span></code></pre></div><h3 id="基于dns服务发现">基于DNS服务发现<a hidden class="anchor" aria-hidden="true" href="#基于dns服务发现">#</a></h3>
<p>支持集群的 DNS 服务器（例如 CoreDNS）监视 Kubernetes API 中的Service，并为每个Service创建一组 DNS 记录。如果在整个集群中都启用了DNS，则所有 Pod 都应该能够通过其 DNS 名称自动解析服务。</p>
<p>例如，如果你在 Kubernetes 命名空间<code>my-ns</code>中有一个名为<code>my-service</code>的Service，则控制节点和DNS服务共同为<code>my-service.my-ns</code>创建DNS记录。<code>my-ns</code>命名空间中的Pod可以直接用名称<code>my-service</code>来找到服务（当然使用<code>my-service.my-ns</code>也可以）。</p>
<p>Kubernetes 从 v1.11 开始可以使用 CoreDNS 来提供命名服务，并从 v1.13 开始成为默认 DNS 服务。CoreDNS 的特点是效率更高，资源占用率更小，推荐使用 CoreDNS 替代 kube-dns 为集群提供 DNS 服务。CoreDNS基本架构如下:</p>
<p><img loading="lazy" src="https://deemoprobe.oss-cn-shanghai.aliyuncs.com/images/20201208151150.png" alt="20201208151150"  />
</p>
<p>如果需要定制DNS服务,可参考下面官方给的方案:<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/dns-custom-nameservers/"  target="_blank" rel="noopener" style="color:#42b983" ;>https://kubernetes.io/zh/docs/tasks/administer-cluster/dns-custom-nameservers/</a></p>
<h4 id="pod-dns">Pod DNS<a hidden class="anchor" aria-hidden="true" href="#pod-dns">#</a></h4>
<p>DNS策略可以逐个Pod来设定。目前 Kubernetes 支持以下特定 Pod 的 DNS 策略。这些策略可以在Pod的<code>spec.dnsPolicy</code>字段设置：</p>
<ul>
<li>&ldquo;Default&rdquo;: Pod 从运行所在的节点继承名称解析配置</li>
<li>&ldquo;ClusterFirst&rdquo;: 与配置的集群域后缀不匹配的任何 DNS 查询（例如 &ldquo;<a href="https://www.kubernetes.io"  target="_blank" rel="noopener" style="color:#42b983" ;>www.kubernetes.io</a>&rdquo;） 都将转发到从节点继承的上游名称服务器。集群管理员可能配置了额外的存根域和上游 DNS 服务器</li>
<li>&ldquo;ClusterFirstWithHostNet&rdquo;：对于以 hostNetwork 方式运行的 Pod，应显式设置其 DNS 策略 &ldquo;ClusterFirstWithHostNet&rdquo;</li>
<li>&ldquo;None&rdquo;: 此设置允许 Pod 忽略 Kubernetes 环境中的 DNS 设置。Pod 会使用其<code>dnsConfig</code>字段所提供的 DNS 设置</li>
</ul>
<blockquote>
<p>说明： &ldquo;Default&rdquo; 不是默认的 DNS 策略。如果未明确指定 dnsPolicy，则使用 &ldquo;ClusterFirst&rdquo;。</p>
</blockquote>
<p>Pod 的 DNS 配置可让用户对 Pod 的 DNS 设置进行更多控制。</p>
<p>dnsConfig 字段是可选的，它可以与任何 dnsPolicy 设置一起使用。 但是，当 Pod 的 dnsPolicy 设置为 &ldquo;None&rdquo; 时，必须指定 dnsConfig 字段。</p>
<p>用户可以在 dnsConfig 字段中指定以下属性：</p>
<ul>
<li>nameservers：将用作于 Pod 的 DNS 服务器的 IP 地址列表。 最多可以指定 3 个 IP 地址。当 Pod 的 dnsPolicy 设置为 &ldquo;None&rdquo; 时， 列表必须至少包含一个 IP 地址，否则此属性是可选的</li>
<li>searches：用于在 Pod 中查找主机名的 DNS 搜索域的列表。此属性是可选的, Kubernetes 最多允许 6 个搜索域</li>
<li>options：可选的对象列表，其中每个对象可能具有 name 属性（必需）和 value 属性（可选）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 创建自定义DNS的Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># vim pod_dns.yaml</span>
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Pod
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: nginx
</span></span><span style="display:flex;"><span>  labels:
</span></span><span style="display:flex;"><span>    app: nginx
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  containers:
</span></span><span style="display:flex;"><span>  - name: nginx
</span></span><span style="display:flex;"><span>    image: nginx:1.18.0
</span></span><span style="display:flex;"><span>    ports:
</span></span><span style="display:flex;"><span>    - containerPort: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>  dnsPolicy: <span style="color:#e6db74">&#34;None&#34;</span>
</span></span><span style="display:flex;"><span>  dnsConfig:
</span></span><span style="display:flex;"><span>    nameservers:
</span></span><span style="display:flex;"><span>      - 8.8.8.8
</span></span><span style="display:flex;"><span>    searches:
</span></span><span style="display:flex;"><span>      - default.svc.cluster-domain.example
</span></span><span style="display:flex;"><span>      - cluster-domain.example
</span></span><span style="display:flex;"><span>    options:
</span></span><span style="display:flex;"><span>      - name: pod_num
</span></span><span style="display:flex;"><span>        value: <span style="color:#e6db74">&#34;1&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl apply -f pod_dns.yaml </span>
</span></span><span style="display:flex;"><span>pod/nginx created
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 查看DNS信息</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl exec nginx -- cat /etc/resolv.conf</span>
</span></span><span style="display:flex;"><span>nameserver 8.8.8.8
</span></span><span style="display:flex;"><span>search default.svc.cluster-domain.example cluster-domain.example
</span></span><span style="display:flex;"><span>options pod_num:1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Pod访问验证</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 创建Service来暴露Pod</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># cat nginx-service.yaml </span>
</span></span><span style="display:flex;"><span>apiVersion: v1
</span></span><span style="display:flex;"><span>kind: Service
</span></span><span style="display:flex;"><span>metadata:
</span></span><span style="display:flex;"><span>  name: nginx-service
</span></span><span style="display:flex;"><span>  labels:
</span></span><span style="display:flex;"><span>    name: nginx-service
</span></span><span style="display:flex;"><span>spec:
</span></span><span style="display:flex;"><span>  ports:
</span></span><span style="display:flex;"><span>  - port: <span style="color:#ae81ff">8180</span>
</span></span><span style="display:flex;"><span>    targetPort: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>  selector:
</span></span><span style="display:flex;"><span>    app: nginx
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl apply -f nginx-service.yaml </span>
</span></span><span style="display:flex;"><span>service/nginx-service created
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl get svc</span>
</span></span><span style="display:flex;"><span>NAME            TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span style="color:#f92672">(</span>S<span style="color:#f92672">)</span>    AGE
</span></span><span style="display:flex;"><span>nginx-service   ClusterIP   10.97.188.44   &lt;none&gt;        8180/TCP   75s
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl exec busybox -- nslookup 10.97.188.44</span>
</span></span><span style="display:flex;"><span>Server:    10.96.0.10
</span></span><span style="display:flex;"><span>Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Name:      10.97.188.44
</span></span><span style="display:flex;"><span>Address 1: 10.97.188.44 nginx-service.default.svc.cluster.local
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>root@k8s-master01 network<span style="color:#f92672">]</span><span style="color:#75715e"># kubectl exec busybox -- wget -q -O- nginx-service.default.svc.cluster.local:8180</span>
</span></span><span style="display:flex;"><span>&lt;!DOCTYPE html&gt;
</span></span><span style="display:flex;"><span>&lt;html&gt;
</span></span><span style="display:flex;"><span>&lt;head&gt;
</span></span><span style="display:flex;"><span>&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</span></span><span style="display:flex;"><span>&lt;style&gt;
</span></span><span style="display:flex;"><span>    body <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        width: 35em;
</span></span><span style="display:flex;"><span>        margin: <span style="color:#ae81ff">0</span> auto;
</span></span><span style="display:flex;"><span>        font-family: Tahoma, Verdana, Arial, sans-serif;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>&lt;/style&gt;
</span></span><span style="display:flex;"><span>&lt;/head&gt;
</span></span><span style="display:flex;"><span>&lt;body&gt;
</span></span><span style="display:flex;"><span>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</span></span><span style="display:flex;"><span>&lt;p&gt;If you see this page, the nginx web server is successfully installed and
</span></span><span style="display:flex;"><span>working. Further configuration is required.&lt;/p&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&lt;p&gt;For online documentation and support please refer to
</span></span><span style="display:flex;"><span>&lt;a href<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;http://nginx.org/&#34;</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
</span></span><span style="display:flex;"><span>Commercial support is available at
</span></span><span style="display:flex;"><span>&lt;a href<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;http://nginx.com/&#34;</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&lt;p&gt;&lt;em&gt;Thank you <span style="color:#66d9ef">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;
</span></span><span style="display:flex;"><span>&lt;/body&gt;
</span></span><span style="display:flex;"><span>&lt;/html&gt;
</span></span></code></pre></div>

        </div>

        <footer class="post-footer">
            
<nav class="paginav">
  <a class="prev" href="https://deemoprobe.github.io/posts/tech/linux/nfs/">
    <span class="title">« 上一页</span>
    <br>
    <span>NFS</span>
  </a>
  <a class="next" href="https://deemoprobe.github.io/posts/tech/kubernetes/kubernetesmetrics/">
    <span class="title">下一页 »</span>
    <br>
    <span>KubernetesMetrics</span>
  </a>
</nav>

        </footer>
    </div>
</article>
</main>

<footer class="footer">
    
        <span id="runtime_span"></span>
        <script
            type="text/javascript">function show_runtime() { window.setTimeout("show_runtime()", 1000); X = new Date("1/1/2023 1:00:00"); Y = new Date(); T = (Y.getTime() - X.getTime()); M = 24 * 60 * 60 * 1000; a = T / M; A = Math.floor(a); b = (a - A) * 24; B = Math.floor(b); c = (b - B) * 60; C = Math.floor((b - B) * 60); D = Math.floor((c - C) * 60); runtime_span.innerHTML = "网站已运行" + A + "天" + B + "小时" + C + "分" + D + "秒" } show_runtime();</script>
    
    
    <br>
    <span>
        Copyright
        &copy;
        2022-2023
        <a href="https://deemoprobe.github.io/" style="color:#939393;">William&#39;s Blog</a>
        All Rights Reserved
    </span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
    document.addEventListener('scroll', function (e) {
        const readProgress = document.getElementById("read_progress");
        const scrollHeight = document.documentElement.scrollHeight;
        const clientHeight = document.documentElement.clientHeight;
        const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
    })
</script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
</script>
<script>
    let mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };
</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        (function() {
            document.cookie = "change-themes" + "="+ escape ("false");
        })()

        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    });
</script>

<script>
    document.body.addEventListener('copy', function (e) {
        if (window.getSelection().toString() && window.getSelection().toString().length > 50) {
            let clipboardData = e.clipboardData || window.clipboardData;
            if (clipboardData) {
                e.preventDefault();
                let htmlData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"William's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                let textData = window.getSelection().toString() +
                    '\r\n\n————————————————\r\n' +
                    '版权声明：本文为「'+"William's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                clipboardData.setData('text/html', htmlData);
                clipboardData.setData('text/plain', textData);
            }
        }
    });
</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;
        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = '📄复制';

        function copyingDone() {
            copybutton.innerText = '👌🏻已复制!';
            setTimeout(() => {
                copybutton.innerText = '📄复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                let text = codeblock.textContent +
                    '\r\n————————————————\r\n' +
                    '版权声明：本文为「'+"William's Blog"+'」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。' +
                '\r\n原文链接：' + location.href;
                navigator.clipboard.writeText(text);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) {}
            selection.removeRange(range);
        });

        let language = codeblock.className.replaceAll("language-", "")
        let macTool = document.createElement("div")
        let macTool1 = document.createElement("div")
        let macTool2 = document.createElement("div")
        let macTool3 = document.createElement("div")
        let languageType = document.createElement("div")
        languageType.innerText = language
        macTool.setAttribute('class', 'mac-tool')
        macTool1.setAttribute('class', 'mac bb1')
        macTool2.setAttribute('class', 'mac bb2')
        macTool3.setAttribute('class', 'mac bb3')
        languageType.setAttribute('class', 'language-type')
        macTool.appendChild(macTool1)
        macTool.appendChild(macTool2)
        macTool.appendChild(macTool3)
        macTool.appendChild(languageType)

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
            container.appendChild(macTool)
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
            container.appendChild(macTool)
        }
    });
</script>

<script>
    $("code[class^=language] ").on("mouseover", function () {
        if (this.clientWidth < this.scrollWidth) {
            $(this).css("width", "135%")
            $(this).css("border-top-right-radius", "var(--radius)")
        }
    }).on("mouseout", function () {
        $(this).css("width", "100%")
        $(this).css("border-top-right-radius", "unset")
    })
</script>
</body>

</html>
